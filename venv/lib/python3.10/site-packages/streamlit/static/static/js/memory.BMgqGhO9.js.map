{"version":3,"file":"memory.BMgqGhO9.js","sources":["../../../../node_modules/native-file-system-adapter/src/adapters/memory.js"],"sourcesContent":["import { errors } from '../util.js'\nimport config from '../config.js'\n\nconst { File, Blob, DOMException } = config\nconst { INVALID, GONE, MISMATCH, MOD_ERR, SYNTAX, SECURITY, DISALLOWED } = errors\n\nexport class Sink {\n\n  /**\n   * @param {FileHandle} fileHandle\n   * @param {File} file\n   */\n  constructor (fileHandle, file) {\n    this.fileHandle = fileHandle\n    this.file = file\n    this.size = file.size\n    this.position = 0\n  }\n\n  write (chunk) {\n    let file = this.file\n\n    if (typeof chunk === 'object') {\n      if (chunk.type === 'write') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.position = chunk.position\n          if (this.size < chunk.position) {\n            this.file = new File(\n              [this.file, new ArrayBuffer(chunk.position - this.size)],\n              this.file.name,\n              this.file\n            )\n          }\n        }\n        if (!('data' in chunk)) {\n          throw new DOMException(...SYNTAX('write requires a data argument'))\n        }\n        chunk = chunk.data\n      } else if (chunk.type === 'seek') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          if (this.size < chunk.position) {\n            throw new DOMException(...INVALID)\n          }\n          this.position = chunk.position\n          return\n        } else {\n          throw new DOMException(...SYNTAX('seek requires a position argument'))\n        }\n      } else if (chunk.type === 'truncate') {\n        if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n          file = chunk.size < this.size\n            ? new File([file.slice(0, chunk.size)], file.name, file)\n            : new File([file, new Uint8Array(chunk.size - this.size)], file.name)\n\n          this.size = file.size\n          if (this.position > file.size) {\n            this.position = file.size\n          }\n          this.file = file\n          return\n        } else {\n          throw new DOMException(...SYNTAX('truncate requires a size argument'))\n        }\n      }\n    }\n\n    chunk = new Blob([chunk])\n\n    let blob = this.file\n    // Calc the head and tail fragments\n    const head = blob.slice(0, this.position)\n    const tail = blob.slice(this.position + chunk.size)\n\n    // Calc the padding\n    let padding = this.position - head.size\n    if (padding < 0) {\n      padding = 0\n    }\n    blob = new File([\n      head,\n      new Uint8Array(padding),\n      chunk,\n      tail\n    ], blob.name)\n\n    this.size = blob.size\n    this.position += chunk.size\n\n    this.file = blob\n  }\n  close () {\n    if (this.fileHandle._deleted) throw new DOMException(...GONE)\n    this.fileHandle._file = this.file\n    this.file =\n    this.position =\n    this.size = null\n    if (this.fileHandle.onclose) {\n      this.fileHandle.onclose(this.fileHandle)\n    }\n  }\n}\n\nexport class FileHandle {\n  constructor (name = '', file = new File([], name), writable = true) {\n    this._file = file\n    this.name = name\n    this.kind = 'file'\n    this._deleted = false\n    this.writable = writable\n    this.readable = true\n  }\n\n  async getFile () {\n    if (this._deleted) throw new DOMException(...GONE)\n    return this._file\n  }\n\n  async createWritable (opts) {\n    if (!this.writable) throw new DOMException(...DISALLOWED)\n    if (this._deleted) throw new DOMException(...GONE)\n\n    const file = opts.keepExistingData\n      ? await this.getFile()\n      : new File([], this.name)\n\n    return new Sink(this, file)\n  }\n\n  async isSameEntry (other) {\n    return this === other\n  }\n\n  async _destroy () {\n    this._deleted = true\n    this._file = null\n  }\n}\n\nexport class FolderHandle {\n\n  /** @param {string} name */\n  constructor (name, writable = true) {\n    this.name = name\n    this.kind = 'directory'\n    this._deleted = false\n    /** @type {Object.<string, (FolderHandle|FileHandle)>} */\n    this._entries = {}\n    this.writable = writable\n    this.readable = true\n  }\n\n  /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */\n  async * entries () {\n    if (this._deleted) throw new DOMException(...GONE)\n    yield* Object.entries(this._entries)\n  }\n\n  async isSameEntry (other) {\n    return this === other\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   */\n  async getDirectoryHandle (name, opts) {\n    if (this._deleted) throw new DOMException(...GONE)\n    const entry = this._entries[name]\n    if (entry) { // entry exist\n      if (entry instanceof FileHandle) {\n        throw new DOMException(...MISMATCH)\n      } else {\n        return entry\n      }\n    } else {\n      if (opts.create) {\n        return (this._entries[name] = new FolderHandle(name))\n      } else {\n        throw new DOMException(...GONE)\n      }\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   */\n  async getFileHandle (name, opts) {\n    const entry = this._entries[name]\n    const isFile = entry instanceof FileHandle\n    if (entry && isFile) return entry\n    if (entry && !isFile) throw new DOMException(...MISMATCH)\n    if (!entry && !opts.create) throw new DOMException(...GONE)\n    if (!entry && opts.create) {\n      return (this._entries[name] = new FileHandle(name))\n    }\n  }\n\n  async removeEntry (name, opts) {\n    const entry = this._entries[name]\n    if (!entry) throw new DOMException(...GONE)\n    await entry._destroy(opts.recursive)\n    delete this._entries[name]\n  }\n\n  async _destroy (recursive) {\n    for (let x of Object.values(this._entries)) {\n      if (!recursive) throw new DOMException(...MOD_ERR)\n      await x._destroy(recursive)\n    }\n    this._entries = {}\n    this._deleted = true\n  }\n}\n\nconst fs = new FolderHandle('')\n\nexport default () => fs\n"],"names":["File","Blob","DOMException","config","INVALID","GONE","MISMATCH","MOD_ERR","SYNTAX","SECURITY","DISALLOWED","errors","Sink","fileHandle","file","chunk","blob","head","tail","padding","FileHandle","name","writable","opts","other","FolderHandle","entry","isFile","recursive","x","fs","memory"],"mappings":"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","x_google_ignoreList":[0]}